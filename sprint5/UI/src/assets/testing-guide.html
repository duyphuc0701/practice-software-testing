<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Testing Guide</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background: #f8f9fa;
      height: 100vh;
      overflow-y: auto;
    }

    .guide-container {
      padding: 20px;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .header {
      background: linear-gradient(135deg, #205d96 0%, #1a4f7f 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header h1 {
      font-size: 20px;
      margin-bottom: 5px;
    }

    .header p {
      font-size: 12px;
      opacity: 0.9;
    }

    .progress-bar {
      background: rgba(255,255,255,0.3);
      height: 6px;
      border-radius: 3px;
      margin-top: 15px;
      overflow: hidden;
    }

    .progress-fill {
      background: white;
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s;
    }

    .features-list {
      flex: 1;
      overflow-y: auto;
    }

    .feature-section {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 15px;
      border-left: 4px solid #205d96;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .feature-section.completed {
      border-left-color: #28a745;
      opacity: 0.8;
    }

    .feature-section.active {
      border-left-color: #ffc107;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .feature-section h2 {
      color: #333;
      font-size: 16px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .step-number {
      background: #205d96;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }

    .completed .step-number {
      background: #28a745;
    }

    .active .step-number {
      background: #ffc107;
      color: #333;
    }

    .user-story {
      background: #f8f9ff;
      border-left: 4px solid #205d96;
      padding: 15px 20px;
      margin: 15px 0;
      font-style: italic;
      color: #205d96;
      border-radius: 0 8px 8px 0;
      font-size: 13px;
      line-height: 1.6;
    }

    .section {
      margin: 15px 0;
    }

    .section h3 {
      color: #4a5568;
      font-size: 13px;
      margin-bottom: 10px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .section-box {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 10px;
    }

    .acceptance-criteria {
      background: #e8f5e8;
      border: 1px solid #4caf50;
    }

    .testing-guidance {
      background: #fff3cd;
      border: 1px solid #ffc107;
    }

    .techniques-box {
      background: #f8f9fa;
      border: 1px solid #6c757d;
    }

    .section-box h4 {
      color: #333;
      font-size: 12px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .acceptance-criteria h4 {
      color: #2e7d32;
    }

    .testing-guidance h4 {
      color: #e65100;
    }

    .techniques-box h4 {
      color: #495057;
    }

    .criteria-list, .guidance-list, .techniques-list {
      list-style: none;
      padding: 0;
    }

    .criteria-list li, .guidance-list li, .techniques-list li {
      margin: 6px 0;
      font-size: 12px;
      line-height: 1.5;
      color: #555;
    }

    .criteria-list li::before {
      content: '✓';
      color: #48bb78;
      font-weight: bold;
      margin-right: 8px;
    }

    .guidance-list li::before {
      content: '→';
      color: #205d96;
      font-weight: bold;
      margin-right: 8px;
    }

    .techniques-list li::before {
      content: '◆';
      color: #6c757d;
      font-weight: bold;
      margin-right: 8px;
    }

    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 15px;
    }

    .checkbox-container input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .checkbox-container label {
      color: #555;
      font-size: 13px;
      cursor: pointer;
    }

    .navigation {
      background: white;
      border-radius: 10px;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      bottom: 0;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    }

    .nav-button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .nav-button.prev {
      background: white;
      color: #205d96;
      border: 1px solid #205d96;
    }

    .nav-button.next {
      background: #205d96;
      color: white;
    }

    .nav-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .nav-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .step-indicator {
      color: #666;
      font-size: 12px;
    }

    .completion-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #e0e0e0;
    }

    .completion-status {
      margin-top: 10px;
    }

    .intro-section {
      padding: 10px 0;
    }

    .intro-section h3 {
      color: #205d96;
      font-size: 16px;
      margin-bottom: 15px;
    }

    .intro-section p {
      color: #555;
      font-size: 13px;
      line-height: 1.6;
      margin-bottom: 10px;
    }

    .technique-card {
      background: #f8f9fa;
      border-left: 4px solid #205d96;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }

    .technique-card h4 {
      color: #2c3e50;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .technique-card p {
      font-size: 12px;
      margin: 8px 0;
    }

    .technique-card ul {
      margin: 5px 0 0 20px;
      font-size: 12px;
      color: #555;
    }

    .technique-card ul li {
      margin: 3px 0;
    }

    .best-practices {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }

    .best-practices h4 {
      color: #2e7d32;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .best-practices ul {
      margin: 0 0 0 20px;
      font-size: 12px;
    }

    .best-practices ul li {
      margin: 5px 0;
      color: #555;
      line-height: 1.5;
    }

    .decision-table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 11px;
    }

    .decision-table th {
      background: #2c3e50;
      color: white;
      padding: 8px 4px;
      text-align: center;
      border: 1px solid #34495e;
    }

    .decision-table td {
      padding: 6px 4px;
      text-align: center;
      border: 1px solid #ddd;
    }

    .decision-table .condition-row td:first-child {
      background: #ecf0f1;
      text-align: left;
      padding-left: 8px;
    }

    .decision-table .condition-row td {
      background: #f8f9fa;
    }

    .decision-table .result-row td:first-child {
      background: #34495e;
      color: white;
      text-align: left;
      padding-left: 8px;
    }

    .decision-table .result-row .success {
      background: #d4edda;
      color: #155724;
      font-weight: bold;
    }

    .decision-table .result-row .error {
      background: #f8d7da;
      color: #721c24;
      font-size: 10px;
    }

    .visual-diagram {
      margin: 15px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }

    .partition-container {
      display: flex;
      gap: 2px;
      margin: 10px 0;
    }

    .partition {
      flex: 1;
      padding: 15px 10px;
      text-align: center;
      border-radius: 6px;
    }

    .invalid-partition {
      background: #ffebee;
      border: 2px solid #ef5350;
    }

    .valid-partition {
      background: #e8f5e9;
      border: 2px solid #66bb6a;
    }

    .partition-label {
      font-size: 11px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }

    .partition-range {
      font-size: 14px;
      font-weight: bold;
      color: #2c3e50;
      margin: 8px 0;
    }

    .partition-test {
      font-size: 11px;
      color: #666;
      margin-top: 5px;
    }

    .bva-container {
      position: relative;
      padding: 20px 10px 40px 10px;
      margin: 10px 0;
    }

    .boundary-line {
      position: relative;
      height: 60px;
      background: linear-gradient(to right, #ffcdd2 0%, #ffcdd2 20%, #c8e6c9 20%, #c8e6c9 70%, #ffcdd2 70%, #ffcdd2 100%);
      border-radius: 4px;
      margin: 10px 0;
    }

    .valid-range {
      position: absolute;
      top: 0;
      height: 100%;
      background: #4caf50;
      opacity: 0.3;
    }

    .boundary-marker {
      position: absolute;
      top: -10px;
      transform: translateX(-50%);
      text-align: center;
    }

    .marker-value {
      background: white;
      border: 2px solid #666;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 11px;
      font-weight: bold;
    }

    .boundary-exact .marker-value {
      border-color: #ff9800;
      background: #fff3e0;
    }

    .marker-label {
      font-size: 16px;
      margin-top: 4px;
    }

    .bva-legend {
      text-align: center;
      font-size: 11px;
      color: #666;
      margin-top: 10px;
      font-style: italic;
    }

    @media (max-height: 600px) {
      .guide-container {
        padding: 10px;
      }
      .header {
        padding: 15px;
      }
      .feature-section {
        padding: 15px;
      }
    }
  </style>
</head>
<body>
<div class="guide-container">
  <div class="header">
    <h1>📋 Testing Guide</h1>
    <p>Testing guide for Practice Software Testing</p>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 2.86%"></div>
    </div>
  </div>

  <div class="features-list" id="featuresList">
    <!-- Single feature will be shown here -->
  </div>

  <div class="navigation">
    <button class="nav-button prev" id="prevBtn" onclick="previousStep()" disabled>
      ← Previous
    </button>
    <span class="step-indicator" id="stepIndicator">Step 1 of 35</span>
    <button class="nav-button next" id="nextBtn" onclick="nextStep()">
      Next →
    </button>
  </div>
</div>

<script>
  const features = [
    {
      title: "Introduction to Black-Box Testing Techniques",
      isIntroduction: true,
      content: `
        <div class="intro-section">
          <h3>🎯 Overview</h3>
          <p>Black-box testing focuses on testing software functionality without knowledge of internal code structure. This guide uses five fundamental techniques to ensure comprehensive test coverage.</p>

          <div class="technique-card">
            <h4>📊 Equivalence Partitioning (EP)</h4>
            <p><strong>What it is:</strong> Divides input data into groups (partitions) where all values in a group should be processed the same way. Each partition represents a set of inputs that trigger the same behavior in the system.</p>

            <p><strong>Core Principle:</strong> If the system handles one value from a partition correctly, it should handle all values in that partition correctly. This allows you to test just one representative value per partition instead of testing every possible input.</p>

            <p><strong>When to use:</strong> When you have ranges of valid/invalid inputs or different categories of data.</p>

            <p><strong>Visual Example:</strong> Age field accepting 17-75</p>
            <div class="visual-diagram">
              <div class="partition-container">
                <div class="partition invalid-partition">
                  <div class="partition-label">Invalid (Too Young)</div>
                  <div class="partition-range">0 — 16</div>
                  <div class="partition-test">Test: 10 ✗</div>
                </div>
                <div class="partition valid-partition">
                  <div class="partition-label">Valid Age Range</div>
                  <div class="partition-range">17 — 75</div>
                  <div class="partition-test">Test: 45 ✓</div>
                </div>
                <div class="partition invalid-partition">
                  <div class="partition-label">Invalid (Too Old)</div>
                  <div class="partition-range">76 — ∞</div>
                  <div class="partition-test">Test: 80 ✗</div>
                </div>
              </div>
            </div>

            <p><strong>Additional Examples:</strong></p>
            <ul>
              <li><strong>Email validation:</strong> Valid partition (user@domain.com), invalid partitions (missing @, missing domain, special chars)</li>
              <li><strong>File upload:</strong> Valid partition (txt, pdf, jpg), invalid partition (exe, zip, dmg)</li>
              <li><strong>Discount codes:</strong> Valid code, expired code, already-used code, non-existent code</li>
              <li><strong>Payment amount:</strong> Negative values, zero, valid positive values, exceeds max limit</li>
            </ul>

            <p><strong>How to apply it:</strong></p>
            <ul>
              <li>1. Identify the input parameter (e.g., age, email, file type)</li>
              <li>2. Determine valid and invalid partitions based on requirements</li>
              <li>3. Select one representative test value from each partition</li>
              <li>4. Create test cases using these representative values</li>
              <li>5. Document expected behavior for each partition</li>
            </ul>

            <p><strong>Why it works:</strong> Reduces test cases dramatically while maintaining coverage. Instead of testing 100 different ages, you test 3 values (one per partition). This is based on the assumption that if one value in a partition works, others likely will too - and bugs typically occur at partition boundaries, not within partitions.</p>

            <p><strong>Pro Tip:</strong> Always combine EP with BVA for maximum effectiveness. EP identifies the partitions, BVA tests the boundaries between them.</p>
          </div>

          <div class="technique-card">
            <h4>🔍 Boundary Value Analysis (BVA)</h4>
            <p><strong>What it is:</strong> Tests values at the edges of input ranges, where errors frequently occur. This technique is based on the empirical observation that most defects cluster around boundaries rather than in the middle of ranges.</p>

            <p><strong>Why boundaries matter:</strong> Programmers commonly make mistakes with comparison operators (< vs <=, > vs >=), array indices (off-by-one errors), and edge conditions. Testing at boundaries catches these issues.</p>

            <p><strong>When to use:</strong> Whenever there are numeric ranges, length limits, date ranges, array indices, file sizes, or any constrained input domain.</p>

            <p><strong>2-Value BVA:</strong> Tests boundary value and just outside boundary</p>
            <div class="visual-diagram">
              <div class="bva-container">
                <div class="boundary-line">
                  <div class="boundary-marker" style="left: 15%;">
                    <div class="marker-value">16</div>
                    <div class="marker-label">✗</div>
                  </div>
                  <div class="boundary-marker boundary-exact" style="left: 20%;">
                    <div class="marker-value">17</div>
                    <div class="marker-label">✓</div>
                  </div>
                  <div class="valid-range" style="left: 20%; width: 50%;"></div>
                  <div class="boundary-marker boundary-exact" style="left: 70%;">
                    <div class="marker-value">75</div>
                    <div class="marker-label">✓</div>
                  </div>
                  <div class="boundary-marker" style="left: 75%;">
                    <div class="marker-value">76</div>
                    <div class="marker-label">✗</div>
                  </div>
                </div>
                <div class="bva-legend">Test Points: 16, 17, 75, 76 (4 test cases)</div>
              </div>
            </div>

            <p><strong>3-Value BVA:</strong> Tests boundary value, just inside, and just outside</p>
            <div class="visual-diagram">
              <div class="bva-container">
                <div class="boundary-line">
                  <div class="boundary-marker" style="left: 15%;">
                    <div class="marker-value">16</div>
                    <div class="marker-label">✗</div>
                  </div>
                  <div class="boundary-marker boundary-exact" style="left: 20%;">
                    <div class="marker-value">17</div>
                    <div class="marker-label">✓</div>
                  </div>
                  <div class="boundary-marker" style="left: 25%;">
                    <div class="marker-value">18</div>
                    <div class="marker-label">✓</div>
                  </div>
                  <div class="valid-range" style="left: 20%; width: 50%;"></div>
                  <div class="boundary-marker" style="left: 65%;">
                    <div class="marker-value">74</div>
                    <div class="marker-label">✓</div>
                  </div>
                  <div class="boundary-marker boundary-exact" style="left: 70%;">
                    <div class="marker-value">75</div>
                    <div class="marker-label">✓</div>
                  </div>
                  <div class="boundary-marker" style="left: 75%;">
                    <div class="marker-value">76</div>
                    <div class="marker-label">✗</div>
                  </div>
                </div>
                <div class="bva-legend">Test Points: 16, 17, 18, 74, 75, 76 (6 test cases)</div>
              </div>
            </div>

            <p><strong>Key Difference:</strong> 2-value BVA is more efficient (fewer tests), while 3-value BVA is more thorough (tests the "just inside" values too).</p>

            <p><strong>Real-world Examples:</strong></p>
            <ul>
              <li><strong>File size limit 500KB:</strong> Test 499KB, 500KB, 501KB</li>
              <li><strong>Character limit 120:</strong> Test strings of length 119, 120, 121</li>
              <li><strong>Date range Jan 1-Dec 31, 2024:</strong> Test Dec 31 2023, Jan 1 2024, Dec 31 2024, Jan 1 2025</li>
              <li><strong>Quantity 1-100:</strong> Test 0, 1, 100, 101</li>
              <li><strong>Discount 0-100%:</strong> Test -1%, 0%, 100%, 101%</li>
            </ul>

            <p><strong>Special Cases:</strong></p>
            <ul>
              <li><strong>Null/Empty:</strong> For strings, test empty string ("") and null</li>
              <li><strong>Zero:</strong> For numeric fields, always test 0 as a special boundary</li>
              <li><strong>Negative boundaries:</strong> Test -1 when minimum is 0</li>
              <li><strong>Maximum values:</strong> Test MAX_INT or system limits for numeric types</li>
            </ul>

            <p><strong>How to apply it:</strong></p>
            <ul>
              <li>1. Identify all input boundaries from requirements (min, max values)</li>
              <li>2. For each boundary, select test values: boundary value, just inside, just outside</li>
              <li>3. Test both upper and lower boundaries</li>
              <li>4. Consider both valid and invalid sides of each boundary</li>
              <li>5. Don't forget special values like 0, null, empty, MAX/MIN</li>
            </ul>

            <p><strong>Why it works:</strong> Studies show that 60-70% of software defects occur at boundaries. Off-by-one errors (using < instead of <=) are among the most common programming mistakes. BVA targets exactly where bugs hide.</p>

            <p><strong>Pro Tip:</strong> When combining with EP, use EP to identify partitions, then apply BVA specifically to the boundaries between partitions for comprehensive coverage.</p>
          </div>

          <div class="technique-card">
            <h4>🔄 State Transition Testing</h4>
            <p><strong>What it is:</strong> Models the system as a finite state machine with defined states and transitions between them. This technique tests both valid transitions (that should work) and invalid transitions (that should be blocked).</p>

            <p><strong>Core Concepts:</strong></p>
            <ul>
              <li><strong>States:</strong> Discrete conditions or modes the system can be in (e.g., Logged Out, Logged In, Locked)</li>
              <li><strong>Transitions:</strong> Events or actions that move the system from one state to another (e.g., login, logout, failed password)</li>
              <li><strong>Guards:</strong> Conditions that must be met for a transition to occur</li>
              <li><strong>Actions:</strong> Side effects that occur during a transition</li>
            </ul>

            <p><strong>When to use:</strong> For features with different states like login/logout, cart states, order processing, account status, workflow systems, game states, or any system with distinct behavioral modes.</p>

            <p><strong>Example: Account States</strong></p>
            <ul>
              <li>Active → (3 failed logins) → Locked</li>
              <li>Locked → (admin unlock) → Active</li>
              <li>Active → (user delete request) → Pending Deletion → (7 days pass) → Deleted</li>
              <li>Invalid: Locked → (user login attempt) → Locked (stays locked)</li>
            </ul>

            <p><strong>Example: Shopping Cart States</strong></p>
            <ul>
              <li>Empty → (add item) → Has Items</li>
              <li>Has Items → (remove last item) → Empty</li>
              <li>Has Items → (checkout) → Checked Out</li>
              <li>Checked Out → (payment success) → Order Placed</li>
              <li>Checked Out → (payment failed) → Has Items</li>
              <li>Invalid: Empty → (checkout) → Should show error, stay Empty</li>
            </ul>

            <p><strong>Example: Order Processing</strong></p>
            <ul>
              <li>Pending → (payment received) → Processing → (shipped) → Shipped → (delivered) → Completed</li>
              <li>Pending → (payment failed after 24h) → Cancelled</li>
              <li>Processing → (out of stock) → Cancelled</li>
              <li>Invalid: Completed → (cancel) → Should be blocked</li>
            </ul>

            <p><strong>How to apply it:</strong></p>
            <ul>
              <li>1. Identify all possible states the system can be in</li>
              <li>2. List all events/actions that trigger transitions</li>
              <li>3. Create a state transition diagram or table</li>
              <li>4. Test all valid transitions (expected paths)</li>
              <li>5. Test invalid transitions (should be rejected)</li>
              <li>6. Test sequences of transitions (paths through multiple states)</li>
              <li>7. Verify the system is in the correct state after each transition</li>
            </ul>

            <p><strong>Coverage Criteria:</strong></p>
            <ul>
              <li><strong>All States:</strong> Visit every state at least once</li>
              <li><strong>All Transitions:</strong> Execute every valid transition at least once</li>
              <li><strong>All Transition Pairs:</strong> Test sequences of two consecutive transitions</li>
              <li><strong>Invalid Transitions:</strong> Attempt transitions that should be blocked</li>
            </ul>

            <p><strong>Common Bugs Found:</strong></p>
            <ul>
              <li>Transitions allowed when they shouldn't be (missing validation)</li>
              <li>System stuck in a state with no way out (missing transitions)</li>
              <li>Wrong state after transition (incorrect state assignment)</li>
              <li>Data inconsistency after state change (side effects not applied)</li>
              <li>Race conditions in concurrent state changes</li>
            </ul>

            <p><strong>Why it works:</strong> Many systems have implicit state machines in their logic. Explicitly modeling and testing these states ensures the system behaves correctly as it moves through different states, handles invalid transitions properly, and maintains data consistency throughout the state lifecycle.</p>

            <p><strong>Pro Tip:</strong> Draw a state diagram first! Visual representation makes it easier to spot missing transitions, unreachable states, and edge cases. Test not just individual transitions, but also paths through multiple states.</p>
          </div>

          <div class="technique-card">
            <h4>📋 Decision Table Testing</h4>
            <p><strong>What it is:</strong> Creates a table of conditions (inputs) and actions (outputs) to systematically test all logical combinations. Each column represents a unique test case covering a specific combination of conditions.</p>

            <p><strong>Structure of a Decision Table:</strong></p>
            <ul>
              <li><strong>Conditions (Input rows):</strong> Boolean or enumerated factors that influence the outcome</li>
              <li><strong>Actions (Output rows):</strong> Results or behaviors that occur for each combination</li>
              <li><strong>Rules (Columns):</strong> Each column is a test case with specific condition values and expected actions</li>
            </ul>

            <p><strong>When to use:</strong> When multiple conditions affect the outcome, especially with complex business rules, eligibility checks, discount calculations, access control, or any logic with AND/OR conditions.</p>

            <p><strong>Example: Login functionality with three conditions</strong></p>
            <table class="decision-table">
              <thead>
                <tr>
                  <th>Test Case</th>
                  <th>1</th>
                  <th>2</th>
                  <th>3</th>
                  <th>4</th>
                  <th>5</th>
                  <th>6</th>
                  <th>7</th>
                  <th>8</th>
                </tr>
              </thead>
              <tbody>
                <tr class="condition-row">
                  <td><strong>Valid Email</strong></td>
                  <td>Y</td>
                  <td>Y</td>
                  <td>Y</td>
                  <td>Y</td>
                  <td>N</td>
                  <td>N</td>
                  <td>N</td>
                  <td>N</td>
                </tr>
                <tr class="condition-row">
                  <td><strong>Valid Password</strong></td>
                  <td>Y</td>
                  <td>Y</td>
                  <td>N</td>
                  <td>N</td>
                  <td>Y</td>
                  <td>Y</td>
                  <td>N</td>
                  <td>N</td>
                </tr>
                <tr class="condition-row">
                  <td><strong>Account Active</strong></td>
                  <td>Y</td>
                  <td>N</td>
                  <td>Y</td>
                  <td>N</td>
                  <td>Y</td>
                  <td>N</td>
                  <td>Y</td>
                  <td>N</td>
                </tr>
                <tr class="result-row">
                  <td><strong>Result</strong></td>
                  <td class="success">✓ Login</td>
                  <td class="error">✗ Locked</td>
                  <td class="error">✗ Wrong PW</td>
                  <td class="error">✗ Wrong PW</td>
                  <td class="error">✗ No User</td>
                  <td class="error">✗ No User</td>
                  <td class="error">✗ No User</td>
                  <td class="error">✗ No User</td>
                </tr>
              </tbody>
            </table>

            <p><strong>Formula:</strong> For N conditions with 2 values each (Y/N), you get 2^N combinations. Example: 3 conditions = 2³ = 8 test cases.</p>

            <p><strong>Additional Examples:</strong></p>

            <p><strong>Discount Eligibility:</strong> Member status (Y/N), Purchase > $100 (Y/N), First Purchase (Y/N) → Different discount percentages</p>

            <p><strong>File Upload Validation:</strong> Valid type (Y/N), Size OK (Y/N), Virus-free (Y/N) → Accept/Reject with specific error messages</p>

            <p><strong>Shipping Calculator:</strong> Weight class (Light/Medium/Heavy), Destination (Domestic/International), Express (Y/N) → Different shipping costs</p>

            <p><strong>How to apply it:</strong></p>
            <ul>
              <li>1. Identify all conditions that influence the decision</li>
              <li>2. Determine possible values for each condition (usually Y/N or enumerated values)</li>
              <li>3. Calculate total combinations: 2^N for binary conditions</li>
              <li>4. Create table with all combinations (each column = one test case)</li>
              <li>5. For each combination, determine the expected action/outcome</li>
              <li>6. Convert each column into a test case</li>
              <li>7. Execute tests and verify actual results match expected actions</li>
            </ul>

            <p><strong>Optimization Techniques:</strong></p>
            <ul>
              <li><strong>Collapse equivalent rules:</strong> If multiple columns have same outcome, they can sometimes be combined</li>
              <li><strong>Don't care values:</strong> Use "-" when a condition doesn't affect the outcome for certain combinations</li>
              <li><strong>Limited-entry tables:</strong> Conditions are Y/N only (easier to create)</li>
              <li><strong>Extended-entry tables:</strong> Conditions can have multiple values (more complex but flexible)</li>
            </ul>

            <p><strong>Common Use Cases:</strong></p>
            <ul>
              <li>Business rule validation (discount eligibility, loan approval)</li>
              <li>Access control (role + permission + resource type → allowed/denied)</li>
              <li>Form validation (multiple required fields + format checks)</li>
              <li>Pricing logic (product type + quantity + customer tier → price)</li>
              <li>Notification triggers (event type + user preference + time → send/don't send)</li>
            </ul>

            <p><strong>Pitfalls to Avoid:</strong></p>
            <ul>
              <li>Too many conditions → combinatorial explosion (8 conditions = 256 test cases!)</li>
              <li>Missing combinations → incomplete table leads to missed bugs</li>
              <li>Incorrect expected outcomes → test passes but requirement is wrong</li>
              <li>Not considering impossible combinations → waste testing effort on scenarios that can't occur</li>
            </ul>

            <p><strong>Why it works:</strong> Complex business logic often involves multiple interacting conditions. Decision tables ensure no combination of conditions is missed and make complex logic testable and traceable. They also serve as excellent documentation of business rules.</p>

            <p><strong>Pro Tip:</strong> Start with exhaustive combinations, then optimize by removing impossible or redundant cases. Decision tables work great alongside EP and BVA - use decision tables for the logical combinations, then apply EP/BVA to the actual values within each condition.</p>
          </div>

          <div class="technique-card">
            <h4>💡 Error Guessing</h4>
            <p><strong>What it is:</strong> An experience-based technique where testers use their knowledge, intuition, and past bug patterns to predict where errors might occur. Unlike systematic techniques, this relies on the tester's expertise and creative thinking.</p>

            <p><strong>Core Philosophy:</strong> Experienced testers develop a "nose for bugs" - they recognize patterns and antipatterns that frequently cause problems. This technique complements systematic approaches by finding the unusual, edge, and adversarial cases.</p>

            <p><strong>When to use:</strong> After systematic testing (EP, BVA, Decision Tables) to supplement coverage. Best used by experienced testers who understand common failure patterns. Also crucial for security testing and adversarial scenarios.</p>

            <p><strong>Common Attack Vectors & Targets:</strong></p>

            <p><strong>1. Input Validation & Injection:</strong></p>
            <ul>
              <li><strong>SQL Injection:</strong> ' OR '1'='1, '; DROP TABLE users;--, admin'--</li>
              <li><strong>XSS attempts:</strong> &lt;script&gt;alert('XSS')&lt;/script&gt;, &lt;img src=x onerror=alert(1)&gt;</li>
              <li><strong>Path traversal:</strong> ../../../etc/passwd, ..\\..\\windows\\system32</li>
              <li><strong>Command injection:</strong> ; ls -la, | cat /etc/passwd</li>
              <li><strong>LDAP injection:</strong> *)(uid=*))(|(uid=*</li>
            </ul>

            <p><strong>2. Boundary & Extreme Values:</strong></p>
            <ul>
              <li><strong>Empty/null:</strong> "", null, undefined, None</li>
              <li><strong>Whitespace variants:</strong> " ", "\t", "\n", "\r\n", multiple spaces</li>
              <li><strong>Zero:</strong> 0, 0.0, -0, +0</li>
              <li><strong>Negative numbers:</strong> -1, -999999, MIN_INT</li>
              <li><strong>Very large numbers:</strong> MAX_INT, 999999999999, Infinity</li>
              <li><strong>Very long strings:</strong> 10,000 character inputs, 1MB text fields</li>
              <li><strong>Very small values:</strong> 0.0000001, scientific notation</li>
            </ul>

            <p><strong>3. Special Characters & Encoding:</strong></p>
            <ul>
              <li><strong>Unicode characters:</strong> 你好, مرحبا, Здравствуй</li>
              <li><strong>Emojis:</strong> 😀🎉💻, emoji-only input</li>
              <li><strong>Special symbols:</strong> @#$%^&*()_+-=[]{}|;':",.<>?/\`~</li>
              <li><strong>Control characters:</strong> \x00 (null byte), \x08 (backspace), \x7F (delete)</li>
              <li><strong>Right-to-left marks:</strong> ‏‎ (RTL override)</li>
              <li><strong>Zero-width characters:</strong> ​ (zero-width space)</li>
            </ul>

            <p><strong>4. Format & Structure:</strong></p>
            <ul>
              <li><strong>Invalid emails:</strong> user@, @domain.com, user@@domain.com, user@domain</li>
              <li><strong>Invalid URLs:</strong> javascript:alert(1), file:///, http://</li>
              <li><strong>Invalid dates:</strong> 2024-02-30, 13/13/2024, 1900-01-01</li>
              <li><strong>Mismatched types:</strong> Strings in number fields, objects where strings expected</li>
            </ul>

            <p><strong>5. State & Timing Issues:</strong></p>
            <ul>
              <li><strong>Race conditions:</strong> Rapid clicking, concurrent requests to same resource</li>
              <li><strong>Session issues:</strong> Expired tokens, logged out mid-operation</li>
              <li><strong>Double submissions:</strong> Submit form twice quickly</li>
              <li><strong>Stale data:</strong> Using cached data after updates</li>
              <li><strong>Timeout scenarios:</strong> Slow network, interrupted operations</li>
            </ul>

            <p><strong>6. Browser & Environment:</strong></p>
            <ul>
              <li><strong>Browser quirks:</strong> Different behavior in Chrome vs Firefox vs Safari</li>
              <li><strong>Cache issues:</strong> Stale cached resources, cache poisoning</li>
              <li><strong>Cookie manipulation:</strong> Deleted cookies, modified session data</li>
              <li><strong>JavaScript disabled:</strong> Does the app degrade gracefully?</li>
              <li><strong>Network conditions:</strong> Offline mode, slow 3G, packet loss</li>
            </ul>

            <p><strong>7. Business Logic Exploitation:</strong></p>
            <ul>
              <li><strong>Negative quantities:</strong> -1 items in cart → refund?</li>
              <li><strong>Discount stacking:</strong> Apply same coupon multiple times</li>
              <li><strong>Price manipulation:</strong> Change price in POST request</li>
              <li><strong>Privilege escalation:</strong> Access admin features as regular user</li>
              <li><strong>Order of operations:</strong> Delete account mid-checkout, change shipping after payment</li>
            </ul>

            <p><strong>Knowledge Sources for Error Guessing:</strong></p>
            <ul>
              <li>Past bugs in similar applications or features</li>
              <li>OWASP Top 10 and common vulnerability lists</li>
              <li>Bug bounty reports and CVE databases</li>
              <li>Developer mistakes you've observed</li>
              <li>Edge cases from support tickets</li>
              <li>Technology-specific quirks (e.g., JavaScript type coercion)</li>
            </ul>

            <p><strong>How to apply it:</strong></p>
            <ul>
              <li>1. Review the feature and think "How would I break this?"</li>
              <li>2. Consider common bug patterns you've seen before</li>
              <li>3. Think adversarially - what would a malicious user try?</li>
              <li>4. Look for assumptions in the code/requirements</li>
              <li>5. Test the "weird" inputs that systematic techniques don't cover</li>
              <li>6. Document successful attacks for future reference</li>
              <li>7. Build a personal checklist from your experience</li>
            </ul>

            <p><strong>Documenting Error Guessing:</strong></p>
            <ul>
              <li>Create checklists of common vulnerabilities for each feature type</li>
              <li>Build test data files with malicious/edge case inputs</li>
              <li>Maintain a bug pattern library from previous projects</li>
              <li>Share findings with team to build collective knowledge</li>
            </ul>

            <p><strong>Limitations:</strong></p>
            <ul>
              <li>Not systematic - coverage is unpredictable</li>
              <li>Quality depends heavily on tester experience</li>
              <li>Hard to measure completeness</li>
              <li>May miss bugs that don't fit expected patterns</li>
              <li>Results vary between different testers</li>
            </ul>

            <p><strong>Why it works:</strong> Systematic techniques are excellent but predictable. Attackers and real users don't follow test plans - they do unexpected things. Error guessing leverages human creativity and pattern recognition to find the bugs that fall through the cracks of formal techniques. It's especially valuable for security testing and finding subtle business logic flaws.</p>

            <p><strong>Pro Tip:</strong> Keep a "bug diary" of interesting bugs you find. Over time, patterns emerge. Also, review security advisories and CVEs for your technology stack - they're goldmines of error guessing ideas. Make error guessing systematic by building checklists, but stay creative!</p>
          </div>

          <div class="best-practices">
            <h4>✅ Best Practices</h4>
            <ul>
              <li><strong>Combine techniques:</strong> Use EP for initial partitions, then apply BVA to boundaries</li>
              <li><strong>Document everything:</strong> Record test cases, expected results, and actual results</li>
              <li><strong>Think negative:</strong> Don't just test happy paths - test what shouldn't work</li>
              <li><strong>Consider combinations:</strong> Real bugs often appear when multiple conditions interact</li>
              <li><strong>Start systematic, then explore:</strong> Use structured techniques first, then error guessing</li>
            </ul>
          </div>
        </div>
      `
    },
    // Register - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Register",
      title: "Register - Determine Test Techniques",
      userStory: "As a visitor, I want to register an account so that I can log in and use personalized features.",
      acceptanceCriteria: [
        "Age must be between 17 and 75 inclusive.",
        "Email must be unique and in valid format.",
        "All mandatory fields (first name, last name, email, password, confirm password) must be filled.",
        "Name/address/phone fields respect max lengths and validation rules.",
        "Password must be at least 8 characters, contain upper, lower, digit, and symbol, not be compromised, and match confirm password."
      ],
      exercisePrompt: "Looking at these acceptance criteria, which testing techniques would you apply?"
    },
    // Register - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Register",
      title: "Register - Testing Techniques & Test Cases",
      userStory: "As a visitor, I want to register an account so that I can log in and use personalized features.",
      acceptanceCriteria: [
        "Age must be between 17 and 75 inclusive.",
        "Email must be unique and in valid format.",
        "All mandatory fields (first name, last name, email, password, confirm password) must be filled.",
        "Name/address/phone fields respect max lengths and validation rules.",
        "Password must be at least 8 characters, contain upper, lower, digit, and symbol, not be compromised, and match confirm password."
      ],
      techniques: [
        "BVA → for age and password length (bugs usually hide at edges).",
        "EP → for valid/invalid email, password character rules, mandatory fields filled/missing.",
        "Decision Table → for combinations of missing fields.",
        "Error Guessing → try SQL injection, emoji, spaces in fields."
      ],
      testCases: [
        "Age: Test 16, 17, 75, 76 (boundary values).",
        "Email: Test valid email, invalid formats, already-used email.",
        "Mandatory Fields: Leave one field empty, then multiple fields, confirm messages appear correctly.",
        "Max Lengths: Test exactly at max length, and one character over.",
        "Password Strength: Try missing each character class, too short, and a compromised password (if system supports it)."
      ]
    },
    // Login - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Login",
      title: "Login - Determine Test Techniques",
      userStory: "As a registered user, I want to log in using my email and password so that I can access my account.",
      acceptanceCriteria: [
        "User can log in with valid credentials.",
        "Login fails with incorrect password, unknown email, or disabled account.",
        "Error messages are clear and specific."
      ],
      exercisePrompt: "Looking at these acceptance criteria, which testing techniques would you apply?"
    },
    // Login - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Login",
      title: "Login - Testing Techniques & Test Cases",
      userStory: "As a registered user, I want to log in using my email and password so that I can access my account.",
      acceptanceCriteria: [
        "User can log in with valid credentials.",
        "Login fails with incorrect password, unknown email, or disabled account.",
        "Error messages are clear and specific."
      ],
      techniques: [
        "EP: valid vs invalid credentials.",
        "State Transition Testing: check transition from 'logged out' → 'logged in' and back after logout.",
        "Error Guessing: try case sensitivity, leading/trailing spaces, SQL injection attempt in email field."
      ],
      testCases: [
        "Valid login: expect redirect to dashboard.",
        "Invalid password: expect error message, no login.",
        "Invalid email: error message, no login.",
        "Disabled account: error message."
      ]
    },
    // Forgot Password - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Forgot Password",
      title: "Forgot Password - Determine Test Techniques",
      userStory: "As a user who forgot my password, I want to reset it using my email so that I can log back in.",
      acceptanceCriteria: [
        "Email must exist in the system.",
        "New password is set to 'welcome02' (for demo).",
        "User can log in with the new password immediately."
      ],
      exercisePrompt: "Which testing techniques are most appropriate for this password reset feature?"
    },
    // Forgot Password - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Forgot Password",
      title: "Forgot Password - Testing Techniques & Test Cases",
      userStory: "As a user who forgot my password, I want to reset it using my email so that I can log back in.",
      acceptanceCriteria: [
        "Email must exist in the system.",
        "New password is set to 'welcome02' (for demo).",
        "User can log in with the new password immediately."
      ],
      techniques: [
        "EP: email exists vs doesn't exist.",
        "State Transition Testing: user state should change from 'cannot log in' → 'can log in'."
      ],
      testCases: [
        "Provide existing email → expect success message, receive new password (or notification).",
        "Provide unknown email → expect clear error.",
        "Try logging in with new password."
      ]
    },
    // Customer Profile - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Customer Profile",
      title: "Customer Profile - Determine Test Techniques",
      userStory: "As a logged-in user, I want to update my profile information and reset my password so that my account details remain correct and secure.",
      acceptanceCriteria: [
        "First name, last name, phone, address fields can be updated.",
        "Password reset cannot reuse the current password.",
        "After password reset, user is logged out automatically."
      ],
      exercisePrompt: "Which testing techniques would best validate profile updates and password changes?"
    },
    // Customer Profile - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Customer Profile",
      title: "Customer Profile - Testing Techniques & Test Cases",
      userStory: "As a logged-in user, I want to update my profile information and reset my password so that my account details remain correct and secure.",
      acceptanceCriteria: [
        "First name, last name, phone, address fields can be updated.",
        "Password reset cannot reuse the current password.",
        "After password reset, user is logged out automatically."
      ],
      techniques: [
        "EP: for valid vs invalid phone, postal code, max lengths.",
        "State Transition Testing: after password reset, user session state changes to logged out.",
        "BVA: for field length max (e.g., 40 chars for city)."
      ],
      testCases: [
        "Update each field individually → confirm persistence after reload.",
        "Attempt password reset with same password → expect rejection.",
        "Reset with new password → confirm logout, then log in with new password."
      ]
    },
    // Customer Favorites - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Customer Favorites",
      title: "Customer Favorites - Determine Test Techniques",
      userStory: "As a logged-in customer, I want to favorite products so that I can quickly find them later.",
      acceptanceCriteria: [
        "User can add a product to favorites from product listing or detail page.",
        "Favorited products appear in the Favorites list.",
        "User can remove a favorite from the list and it no longer appears."
      ],
      exercisePrompt: "What techniques would you use to test adding and removing favorites?"
    },
    // Customer Favorites - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Customer Favorites",
      title: "Customer Favorites - Testing Techniques & Test Cases",
      userStory: "As a logged-in customer, I want to favorite products so that I can quickly find them later.",
      acceptanceCriteria: [
        "User can add a product to favorites from product listing or detail page.",
        "Favorited products appear in the Favorites list.",
        "User can remove a favorite from the list and it no longer appears."
      ],
      techniques: [
        "State Transition Testing: product state changes from 'not favorite' → 'favorite' → 'not favorite'.",
        "Equivalence Partitioning: valid product vs unavailable product.",
        "Error Guessing: try to favorite when logged out → expect proper error."
      ],
      testCases: [
        "Add multiple products → check they all appear.",
        "Remove one → confirm only that product is removed.",
        "Try adding same product twice → check for duplicates or error.",
        "Log out & log back in → favorites should persist."
      ]
    },
    // Customer Invoices - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Customer Invoices",
      title: "Customer Invoices - Determine Test Techniques",
      userStory: "As a customer, I want to view and download my invoices so that I can track my purchases.",
      acceptanceCriteria: [
        "List of invoices is shown for logged-in user.",
        "Clicking invoice shows detail page.",
        "Download button provides correct PDF file."
      ],
      exercisePrompt: "Which testing techniques would validate invoice viewing and security?"
    },
    // Customer Invoices - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Customer Invoices",
      title: "Customer Invoices - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to view and download my invoices so that I can track my purchases.",
      acceptanceCriteria: [
        "List of invoices is shown for logged-in user.",
        "Clicking invoice shows detail page.",
        "Download button provides correct PDF file."
      ],
      techniques: [
        "EP: logged-in vs logged-out (should not see invoices).",
        "State Transition Testing: selecting invoice transitions from list view → detail view.",
        "Error Guessing: try direct URL access for another customer's invoice → expect 403/404."
      ],
      testCases: [
        "Verify invoices belong to logged-in customer only.",
        "Check invoice detail matches data on list (dates, totals).",
        "Download PDF → open file, verify correct content."
      ]
    },
    // Customer Messages - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Customer Messages",
      title: "Customer Messages - Determine Test Techniques",
      userStory: "As a customer, I want to view and reply to my contact messages so that I can continue conversations with support.",
      acceptanceCriteria: [
        "All past messages appear chronologically.",
        "Reply field is available and messages send successfully."
      ],
      exercisePrompt: "Which testing techniques apply to message threading and replies?"
    },
    // Customer Messages - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Customer Messages",
      title: "Customer Messages - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to view and reply to my contact messages so that I can continue conversations with support.",
      acceptanceCriteria: [
        "All past messages appear chronologically.",
        "Reply field is available and messages send successfully."
      ],
      techniques: [
        "EP: valid message vs empty/too long message.",
        "Decision Table: combinations of message + attachment (if supported).",
        "Error Guessing: attempt sending reply while offline → expect graceful error."
      ],
      testCases: [
        "Open message thread, check ordering.",
        "Send reply → verify it appears instantly or after refresh.",
        "Try empty reply → expect validation error."
      ]
    },
    // Locked Account - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Locked Account",
      title: "Locked Account - Determine Test Techniques",
      userStory: "As a user, I want my account to lock after repeated failed logins so that my account is protected against brute-force attacks.",
      acceptanceCriteria: [
        "After 3 failed password attempts, account is locked.",
        "Lock message is shown: 'Account locked, too many failed attempts. Please contact the administrator.'",
        "Admin can unlock account; user can log in again after unlock."
      ],
      exercisePrompt: "Which techniques would test the account locking mechanism and state transitions?"
    },
    // Locked Account - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Locked Account",
      title: "Locked Account - Testing Techniques & Test Cases",
      userStory: "As a user, I want my account to lock after repeated failed logins so that my account is protected against brute-force attacks.",
      acceptanceCriteria: [
        "After 3 failed password attempts, account is locked.",
        "Lock message is shown: 'Account locked, too many failed attempts. Please contact the administrator.'",
        "Admin can unlock account; user can log in again after unlock."
      ],
      techniques: [
        "State Transition Testing: state: active → locked → active (after unlock).",
        "BVA: 2 wrong attempts still allow login, 3rd locks.",
        "Error Guessing: attempt concurrent logins from multiple devices."
      ],
      testCases: [
        "Try 3 wrong passwords → verify lock and message.",
        "Attempt login after lock → still blocked.",
        "Unlock account (simulate admin action) → login works again."
      ]
    },
    // Multi-Factor Authentication (MFA) - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Multi-Factor Authentication (MFA)",
      title: "Multi-Factor Authentication (MFA) - Determine Test Techniques",
      userStory: "As a security-conscious customer, I want to set up MFA so that I have extra protection when logging in.",
      acceptanceCriteria: [
        "Customer can enable MFA by scanning QR code.",
        "System verifies TOTP.",
        "After enablement, each new login requires TOTP."
      ],
      exercisePrompt: "Which techniques test MFA enablement and TOTP verification?"
    },
    // Multi-Factor Authentication (MFA) - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Multi-Factor Authentication (MFA)",
      title: "Multi-Factor Authentication (MFA) - Testing Techniques & Test Cases",
      userStory: "As a security-conscious customer, I want to set up MFA so that I have extra protection when logging in.",
      acceptanceCriteria: [
        "Customer can enable MFA by scanning QR code.",
        "System verifies TOTP.",
        "After enablement, each new login requires TOTP."
      ],
      techniques: [
        "State Transition Testing: state: MFA-disabled → enabled.",
        "EP: valid vs invalid TOTP.",
        "Error Guessing: test expired TOTP, reused TOTP."
      ],
      testCases: [
        "Enable MFA → test with valid/invalid TOTP.",
        "Login again → confirm prompt for TOTP.",
        "Provide wrong TOTP → expect rejection."
      ]
    },
    // Contact Form - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Contact Form",
      title: "Contact Form - Determine Test Techniques",
      userStory: "As a logged-in user, I want to contact support and attach files so that I can report issues effectively.",
      acceptanceCriteria: [
        "Name (≤120 chars), subject (≤120), message (≤250) are required.",
        "Email required if not inferred from user profile.",
        "File upload: Must allow only txt, pdf, jpg. Must reject >500KB or 0KB. Show descriptive error for invalid file."
      ],
      exercisePrompt: "Which techniques test field validation and file upload constraints?"
    },
    // Contact Form - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Contact Form",
      title: "Contact Form - Testing Techniques & Test Cases",
      userStory: "As a logged-in user, I want to contact support and attach files so that I can report issues effectively.",
      acceptanceCriteria: [
        "Name (≤120 chars), subject (≤120), message (≤250) are required.",
        "Email required if not inferred from user profile.",
        "File upload: Must allow only txt, pdf, jpg. Must reject >500KB or 0KB. Show descriptive error for invalid file."
      ],
      techniques: [
        "BVA: file size just below, at, just above 500KB.",
        "EP: valid/invalid file types.",
        "Decision Table: combinations of file/no file, message filled/empty.",
        "Error Guessing: try filename with special characters."
      ],
      testCases: [
        "Test valid message with each allowed file type.",
        "Test empty message → expect error.",
        "Upload invalid file type (.exe) → error shown.",
        "Upload file slightly >500KB → error shown.",
        "Upload file exactly 500KB → accepted."
      ]
    },
    // Product Listing - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Product Listing",
      title: "Product Listing - Determine Test Techniques",
      userStory: "As a customer, I want to filter, sort, and search products so that I can find what I need quickly.",
      acceptanceCriteria: [
        "Filtering by category/brand shows matching products only.",
        "Sorting by name/price works in both directions.",
        "Price range filters products correctly.",
        "Reset search clears filters and shows all products."
      ],
      exercisePrompt: "Which techniques test filter/sort combinations and reset functionality?"
    },
    // Product Listing - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Product Listing",
      title: "Product Listing - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to filter, sort, and search products so that I can find what I need quickly.",
      acceptanceCriteria: [
        "Filtering by category/brand shows matching products only.",
        "Sorting by name/price works in both directions.",
        "Price range filters products correctly.",
        "Reset search clears filters and shows all products."
      ],
      techniques: [
        "Decision Table: combinations of filters and sorts.",
        "EP: valid category vs invalid category (URL tampering).",
        "Error Guessing: combine multiple filters + no results scenario."
      ],
      testCases: [
        "Apply filter → check results match criteria.",
        "Apply sort → check order.",
        "Combine filter + sort → still correct.",
        "Reset → all products visible again."
      ]
    },
    // Category Page - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Category Page",
      title: "Category Page - Determine Test Techniques",
      userStory: "As a customer, I want to browse products by category with sorting and filtering options so that I can find relevant products efficiently.",
      acceptanceCriteria: [
        "Products are listed from a specific category only.",
        "Sorting works for name (A-Z), name (Z-A), price (High-Low), price (Low-High).",
        "Filtering works by sub category and brand.",
        "All filters and sorts can be combined."
      ],
      exercisePrompt: "Which techniques would validate category filtering, sorting, and combinations?"
    },
    // Category Page - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Category Page",
      title: "Category Page - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to browse products by category with sorting and filtering options so that I can find relevant products efficiently.",
      acceptanceCriteria: [
        "Products are listed from a specific category only.",
        "Sorting works for name (A-Z), name (Z-A), price (High-Low), price (Low-High).",
        "Filtering works by sub category and brand.",
        "All filters and sorts can be combined."
      ],
      techniques: [
        "Decision Table: combinations of sorting (4 options) and filtering (sub category + brand).",
        "EP: valid category vs invalid category, valid filters vs invalid filters.",
        "State Transition: navigating category → filtered results → product detail → back.",
        "Error Guessing: URL manipulation for invalid category IDs, combining incompatible filters."
      ],
      testCases: [
        "Verify page shows only products from the selected category.",
        "Test each sorting option: name A-Z, name Z-A, price High-Low, price Low-High.",
        "Apply sub category filter → verify only matching products appear.",
        "Apply brand filter → verify only matching products appear.",
        "Combine sorting + filtering → verify results are both sorted and filtered correctly.",
        "Test pagination if many products in category."
      ]
    },
    // Product Detail Page - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Product Detail Page",
      title: "Product Detail Page - Determine Test Techniques",
      userStory: "As a customer, I want to view product details, configure rental duration or quantity, and add items to cart or favorites.",
      acceptanceCriteria: [
        "For rental products: Duration in hours selector is available, total price is calculated based on selected duration, add to cart and add to favorites buttons work correctly.",
        "For regular products: Quantity field is available, add to cart and add to favorites buttons work correctly.",
        "Add to favorites requires user to be logged in, otherwise shows error.",
        "All calculations and interactions work as expected."
      ],
      exercisePrompt: "Which techniques test product configuration, calculations, and authentication requirements?"
    },
    // Product Detail Page - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Product Detail Page",
      title: "Product Detail Page - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to view product details, configure rental duration or quantity, and add items to cart or favorites.",
      acceptanceCriteria: [
        "For rental products: Duration in hours selector is available, total price is calculated based on selected duration, add to cart and add to favorites buttons work correctly.",
        "For regular products: Quantity field is available, add to cart and add to favorites buttons work correctly.",
        "Add to favorites requires user to be logged in, otherwise shows error.",
        "All calculations and interactions work as expected."
      ],
      techniques: [
        "BVA: duration hours (minimum, maximum, boundary values), quantity (0, 1, maximum allowed).",
        "EP: logged-in vs logged-out users for favorites, rental vs regular products, valid vs invalid input values.",
        "Decision Table: combinations of product type (rental/regular), user state (logged-in/out), action (add to cart/favorites).",
        "Error Guessing: rapidly clicking buttons, invalid input values, browser back/forward during selection."
      ],
      testCases: [
        "Rental Products: Test duration selector with different hour values → verify total price calculation is correct.",
        "Rental Products: Test add to cart with various durations → verify correct item and price added to cart.",
        "Rental Products: Test add to favorites while logged in → verify success, while logged out → verify error message.",
        "Regular Products: Test quantity field with values like 1, 5, maximum allowed → verify quantity is respected.",
        "Regular Products: Test add to cart with different quantities → verify correct quantity added.",
        "Regular Products: Test add to favorites while logged in → verify success, while logged out → verify error message.",
        "Test boundary cases: minimum/maximum duration hours, minimum/maximum quantity values.",
        "Test error scenarios: invalid duration, invalid quantity, network errors."
      ]
    },
    // Shopping Cart - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Shopping Cart",
      title: "Shopping Cart - Determine Test Techniques",
      userStory: "As a customer, I want to manage my cart so that I can control what I purchase.",
      acceptanceCriteria: [
        "Show empty cart message when empty.",
        "Add product → appears in cart.",
        "Remove product → disappears.",
        "Discount price shown if applicable."
      ],
      exercisePrompt: "Which techniques test cart state transitions and discount calculations?"
    },
    // Shopping Cart - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Shopping Cart",
      title: "Shopping Cart - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to manage my cart so that I can control what I purchase.",
      acceptanceCriteria: [
        "Show empty cart message when empty.",
        "Add product → appears in cart.",
        "Remove product → disappears.",
        "Discount price shown if applicable."
      ],
      techniques: [
        "State Transition: cart empty → has items → empty.",
        "EP: with/without discount.",
        "Error Guessing: remove product while in checkout."
      ],
      testCases: [
        "Add/remove multiple items.",
        "Check discount calculation correctness.",
        "Refresh page → cart persists."
      ]
    },
    // Checkout + Payment - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Checkout + Payment",
      title: "Checkout + Payment - Determine Test Techniques",
      userStory: "As a customer, I want to checkout with different payment methods so that I can complete my purchase securely.",
      acceptanceCriteria: [
        "Guest checkout requires all billing fields (street, city, country, etc.).",
        "Bank Transfer: Bank Name (letters/spaces only), Account Name (alphanumeric + spaces/dots/apostrophes/hyphens), Account Number (digits only).",
        "Credit Card: Number (####-####-####-#### format), Expiration (MM/YYYY, future date), CVV (3-4 digits), Card Holder Name (letters/spaces only).",
        "Buy Now Pay Later: Must select 3, 6, 9, or 12 installments.",
        "Gift Card: Card Number (alphanumeric), Validation Code (alphanumeric).",
        "Cash on Delivery: No additional fields required."
      ],
      exercisePrompt: "Which techniques validate complex payment method combinations and field formats?"
    },
    // Checkout + Payment - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Checkout + Payment",
      title: "Checkout + Payment - Testing Techniques & Test Cases",
      userStory: "As a customer, I want to checkout with different payment methods so that I can complete my purchase securely.",
      acceptanceCriteria: [
        "Guest checkout requires all billing fields (street, city, country, etc.).",
        "Bank Transfer: Bank Name (letters/spaces only), Account Name (alphanumeric + spaces/dots/apostrophes/hyphens), Account Number (digits only).",
        "Credit Card: Number (####-####-####-#### format), Expiration (MM/YYYY, future date), CVV (3-4 digits), Card Holder Name (letters/spaces only).",
        "Buy Now Pay Later: Must select 3, 6, 9, or 12 installments.",
        "Gift Card: Card Number (alphanumeric), Validation Code (alphanumeric).",
        "Cash on Delivery: No additional fields required."
      ],
      techniques: [
        "Decision Table: combinations of valid/invalid fields for each payment method (5 methods × multiple fields = extensive matrix).",
        "BVA: field lengths at max (255 chars), expiration date (today, tomorrow, yesterday), CVV digits (2, 3, 4, 5).",
        "EP: valid formats vs invalid formats, required vs optional fields, different payment method categories.",
        "Error Guessing: special characters in numeric fields, different date formats, mixed case in regex patterns."
      ],
      testCases: [
        "Bank Transfer: Test invalid bank name (with numbers), account name (with symbols), account number (with letters).",
        "Credit Card: Test wrong format (spaces instead of hyphens), past expiration date, 2-digit CVV, card holder name with numbers.",
        "Buy Now Pay Later: Test invalid installment numbers (1, 5, 15), non-numeric values.",
        "Gift Card: Test card number/validation code with special characters.",
        "Test boundary values: exactly at max length vs one character over."
      ]
    },
    // Geolocation Discount - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Geolocation Discount",
      title: "Geolocation Discount - Determine Test Techniques",
      userStory: "As a visitor, I want location-based discounts to apply automatically so that I get the correct pricing for my region.",
      acceptanceCriteria: [
        "New York (lat: 41, lng: 74) → 5% discount.",
        "Mumbai (lat: 19, lng: 73) → 10% discount.",
        "Tokyo (lat: 35, lng: 139) → 15% discount.",
        "Amsterdam (lat: 52, lng: 5) → 20% discount.",
        "London (lat: 51, lng: 0) → 25% discount.",
        "Any other location → no discount applied."
      ],
      exercisePrompt: "Which techniques test coordinate matching and discount calculations?"
    },
    // Geolocation Discount - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Geolocation Discount",
      title: "Geolocation Discount - Testing Techniques & Test Cases",
      userStory: "As a visitor, I want location-based discounts to apply automatically so that I get the correct pricing for my region.",
      acceptanceCriteria: [
        "New York (lat: 41, lng: 74) → 5% discount.",
        "Mumbai (lat: 19, lng: 73) → 10% discount.",
        "Tokyo (lat: 35, lng: 139) → 15% discount.",
        "Amsterdam (lat: 52, lng: 5) → 20% discount.",
        "London (lat: 51, lng: 0) → 25% discount.",
        "Any other location → no discount applied."
      ],
      techniques: [
        "BVA: coordinates at exact values (41,74) vs nearby values (40,74), (41,75).",
        "EP: valid city coordinates vs invalid coordinates vs edge coordinates.",
        "Decision Table: combinations of valid lat/lng for each city vs invalid combinations.",
        "Error Guessing: negative coordinates, coordinates as strings, missing coordinates, extreme values."
      ],
      testCases: [
        "Test exact coordinates for each city → verify correct discount percentage.",
        "Test coordinates slightly off (±1 degree) → confirm no discount.",
        "Test invalid coordinates (lat > 90, lng > 180) → handle gracefully.",
        "Test edge case coordinates (lat: 0, lng: 0) → no discount.",
        "Test decimal coordinates vs integer coordinates → behavior consistency."
      ]
    },
    // Combined Product Discount - Page 1: User Story + Acceptance Criteria + Techniques Exercise
    {
      type: "techniquesExercise",
      featureName: "Combined Product Discount",
      title: "Combined Product Discount - Determine Test Techniques",
      userStory: "As a shopper, I want to receive a discount when I buy a regular + rental product together so that I save money.",
      acceptanceCriteria: [
        "When cart contains both types → 15% discount applied.",
        "When only one type → no extra discount."
      ],
      exercisePrompt: "Which techniques test cart composition and discount application?"
    },
    // Combined Product Discount - Page 2: Full Solution with Test Cases
    {
      type: "testCases",
      featureName: "Combined Product Discount",
      title: "Combined Product Discount - Testing Techniques & Test Cases",
      userStory: "As a shopper, I want to receive a discount when I buy a regular + rental product together so that I save money.",
      acceptanceCriteria: [
        "When cart contains both types → 15% discount applied.",
        "When only one type → no extra discount."
      ],
      techniques: [
        "Decision Table: cart with combinations of product types.",
        "EP: both present vs only one."
      ],
      testCases: [
        "Add regular + rental → check discount calculation.",
        "Remove one → discount disappears."
      ]
    }
  ];

  let currentStep = 0;

  function initializeGuide() {
    loadCurrentStep();
    loadProgress();
    renderCurrentFeature();
    updateProgress();
    updateNavigation();
  }

  function renderCurrentFeature() {
    const container = document.getElementById('featuresList');
    const feature = features[currentStep];

    if (feature.isIntroduction) {
      container.innerHTML = `
        <div class="feature-section active" id="feature-${currentStep}">
          <h2>
            <span class="step-number">${currentStep + 1}</span>
            ${feature.title}
          </h2>
          ${feature.content}
          <div class="completion-section">
            <div class="checkbox-container">
              <input type="checkbox" id="complete-${currentStep}" onchange="markComplete(${currentStep})" ${isCompleted(currentStep) ? 'checked' : ''}>
              <label for="complete-${currentStep}">Mark as read</label>
            </div>
            <div class="completion-status" id="completion-status">
              ${getCompletionSummary()}
            </div>
          </div>
        </div>
      `;
    } else if (feature.type === 'userStoryExercise') {
      // Page 1: User Story + Exercise to write acceptance criteria
      container.innerHTML = `
        <div class="feature-section active" id="feature-${currentStep}">
          <h2>
            <span class="step-number">${currentStep + 1}</span>
            ${feature.title}
          </h2>

          <div class="section">
            <h3>📖 User Story</h3>
            <div class="user-story">
              <blockquote>
                <em>${feature.userStory}</em>
              </blockquote>
            </div>
          </div>

          <div class="section-box testing-guidance">
            <h4>📝 Exercise</h4>
            <p style="margin: 0; color: #555; font-size: 13px; line-height: 1.6;">${feature.exercisePrompt}</p>
          </div>

          <div class="completion-section">
            <div class="checkbox-container">
              <input type="checkbox" id="complete-${currentStep}" onchange="markComplete(${currentStep})" ${isCompleted(currentStep) ? 'checked' : ''}>
              <label for="complete-${currentStep}">Mark as completed</label>
            </div>
            <div class="completion-status" id="completion-status">
              ${getCompletionSummary()}
            </div>
          </div>
        </div>
      `;
    } else if (feature.type === 'criteriaExercise' || feature.type === 'techniquesExercise') {
      // Page 1 (2-page format): Acceptance Criteria + Exercise to determine techniques
      container.innerHTML = `
        <div class="feature-section active" id="feature-${currentStep}">
          <h2>
            <span class="step-number">${currentStep + 1}</span>
            ${feature.title}
          </h2>

          <div class="section">
            <h3>📖 User Story</h3>
            <div class="user-story">
              <blockquote>
                <em>${feature.userStory}</em>
              </blockquote>
            </div>
          </div>

          <div class="section-box acceptance-criteria">
            <h4>✅ Acceptance Criteria</h4>
            <ul class="criteria-list">
              ${feature.acceptanceCriteria.map(criteria => `<li>${criteria}</li>`).join('')}
            </ul>
          </div>

          <div class="section-box testing-guidance">
            <h4>📝 Exercise</h4>
            <p style="margin: 0; color: #555; font-size: 13px; line-height: 1.6;">${feature.exercisePrompt}</p>
          </div>

          <div class="completion-section">
            <div class="checkbox-container">
              <input type="checkbox" id="complete-${currentStep}" onchange="markComplete(${currentStep})" ${isCompleted(currentStep) ? 'checked' : ''}>
              <label for="complete-${currentStep}">Mark as completed</label>
            </div>
            <div class="completion-status" id="completion-status">
              ${getCompletionSummary()}
            </div>
          </div>
        </div>
      `;
    } else if (feature.type === 'testCases') {
      // Page 3: Techniques + Test Cases
      container.innerHTML = `
        <div class="feature-section active" id="feature-${currentStep}">
          <h2>
            <span class="step-number">${currentStep + 1}</span>
            ${feature.title}
          </h2>

          <div class="section">
            <h3>📖 User Story</h3>
            <div class="user-story">
              <blockquote>
                <em>${feature.userStory}</em>
              </blockquote>
            </div>
          </div>

          <div class="section-box acceptance-criteria">
            <h4>✅ Acceptance Criteria</h4>
            <ul class="criteria-list">
              ${feature.acceptanceCriteria.map(criteria => `<li>${criteria}</li>`).join('')}
            </ul>
          </div>

          <div class="section-box techniques-box">
            <h4>🔧 Testing Techniques to Apply</h4>
            <ul class="techniques-list">
              ${feature.techniques.map(technique => `<li>${technique}</li>`).join('')}
            </ul>
          </div>

          <div class="section-box testing-guidance">
            <h4>🧪 Test Cases (High Level)</h4>
            <ul class="guidance-list">
              ${feature.testCases.map(testCase => `<li>${testCase}</li>`).join('')}
            </ul>
          </div>

          <div class="completion-section">
            <div class="checkbox-container">
              <input type="checkbox" id="complete-${currentStep}" onchange="markComplete(${currentStep})" ${isCompleted(currentStep) ? 'checked' : ''}>
              <label for="complete-${currentStep}">Mark as completed</label>
            </div>
            <div class="completion-status" id="completion-status">
              ${getCompletionSummary()}
            </div>
          </div>
        </div>
      `;
    }
  }

  function updateProgress() {
    const progress = ((currentStep + 1) / features.length) * 100;
    document.getElementById('progressFill').style.width = `${progress}%`;
    document.getElementById('stepIndicator').textContent = `Step ${currentStep + 1} of ${features.length}`;
  }

  function updateNavigation() {
    document.getElementById('prevBtn').disabled = currentStep === 0;
    document.getElementById('nextBtn').disabled = currentStep === features.length - 1;
  }

  function nextStep() {
    if (currentStep < features.length - 1) {
      currentStep++;
      saveCurrentStep();
      renderCurrentFeature();
      updateProgress();
      updateNavigation();
    }
  }

  function previousStep() {
    if (currentStep > 0) {
      currentStep--;
      saveCurrentStep();
      renderCurrentFeature();
      updateProgress();
      updateNavigation();
    }
  }

  function isCompleted(index) {
    const saved = localStorage.getItem('testing-guide-progress');
    if (saved) {
      const progress = JSON.parse(saved);
      return progress.completed && progress.completed[index];
    }
    return false;
  }

  function getCompletionSummary() {
    const completed = features.filter((_, index) => isCompleted(index)).length;
    const total = features.length;
    const percentage = Math.round((completed / total) * 100);

    if (completed === total) {
      return `<div style="color: #28a745; font-size: 12px; margin-top: 10px;">🎉 All features tested! (${completed}/${total})</div>`;
    } else if (completed > 0) {
      return `<div style="color: #205d96; font-size: 12px; margin-top: 10px;">Progress: ${completed}/${total} features tested (${percentage}%)</div>`;
    } else {
      return `<div style="color: #666; font-size: 12px; margin-top: 10px;">Start testing your first feature to track progress</div>`;
    }
  }

  function saveCurrentStep() {
    localStorage.setItem('testing-guide-current-step', currentStep.toString());
  }

  function loadCurrentStep() {
    const saved = localStorage.getItem('testing-guide-current-step');
    if (saved) {
      currentStep = parseInt(saved, 10) || 0;
    }
  }

  function markComplete(index) {
    const section = document.getElementById(`feature-${index}`);
    const checkbox = document.getElementById(`complete-${index}`);

    if (checkbox.checked) {
      section.classList.add('completed');
      // Auto-advance to next step if not the last one
      if (index === currentStep && currentStep < features.length - 1) {
        setTimeout(() => nextStep(), 500);
      }
    } else {
      section.classList.remove('completed');
    }

    // Store progress in localStorage
    const saved = localStorage.getItem('testing-guide-progress');
    const progress = saved ? JSON.parse(saved) : { completed: new Array(features.length).fill(false) };

    progress.completed[index] = checkbox.checked;
    localStorage.setItem('testing-guide-progress', JSON.stringify(progress));

    // Update completion summary
    document.getElementById('completion-status').innerHTML = getCompletionSummary();
  }

  // Load saved progress
  function loadProgress() {
    const saved = localStorage.getItem('testing-guide-progress');
    if (saved) {
      const progress = JSON.parse(saved);
      progress.completed.forEach((isCompleted, index) => {
        const checkbox = document.getElementById(`complete-${index}`);
        if (checkbox && isCompleted) {
          checkbox.checked = true;
          document.getElementById(`feature-${index}`).classList.add('completed');
        }
      });
    }
  }

  // Initialize on load
  document.addEventListener('DOMContentLoaded', () => {
    initializeGuide();
  });

  // Listen for messages from parent window
  window.addEventListener('message', (event) => {
    if (event.data === 'focus-guide') {
      window.focus();
    }
  });
</script>
</body>
</html>
